<h1 id="hmc-cs-131">HMC CS 131</h1>
<h2 id="week-1-lecture-1-introduction-to-haskell-and-functional-programming">Week 1, Lecture 1: Introduction to Haskell and Functional Programming</h2>
<h3 id="todays-topics">Today’s Topics</h3>
<ul>
<li>The Read-Eval-Print Loop (REPL)</li>
<li>A Tour of Haskell:
<ul>
<li>Basic values and types (numerics, booleans, characters, strings, lists, tuples)</li>
<li>Calling functions</li>
<li>Variables, bindings, and scope</li>
<li>Writing code in files</li>
<li>Defining functions</li>
<li>Types</li>
</ul></li>
<li>Functional Programming: definitions and foundations</li>
<li>Abstraction: The Essence of CS 131</li>
</ul>
<h3 id="haskell-getting-started">Haskell: Getting Started</h3>
<h4 id="repl">REPL</h4>
<p>The REPL (Read-Eval-Print Loop) is an interactive environment for executing Haskell code. It consists of the following steps:</p>
<ol type="1">
<li><strong>Read</strong>: Read the input from the user</li>
<li><strong>Eval</strong>: Evaluate the input code</li>
<li><strong>Print</strong>: Print the result of the evaluation</li>
<li><strong>Loop</strong>: Go back to the Read step</li>
</ol>
<h4 id="repl-example-ghci">REPL Example: GHCI</h4>
<p>To use the REPL in Haskell, you can launch <code>ghci</code> (Glasgow Haskell Compiler Interactive) in your terminal.</p>
<h3 id="haskell-basic-values-and-types">Haskell: Basic Values and Types</h3>
<p>Haskell has a variety of basic values and types, as shown in the table below:</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1, 2, 100000000000, -42, …</td>
<td>Integer</td>
<td>Whole numbers</td>
</tr>
<tr class="even">
<td>3.14, 3.2831, -2.718, …</td>
<td>Double</td>
<td>Floating-point numbers</td>
</tr>
<tr class="odd">
<td>True, False</td>
<td>Bool</td>
<td>Booleans</td>
</tr>
<tr class="even">
<td>‘a’, ‘z’, …</td>
<td>Char</td>
<td>Characters</td>
</tr>
<tr class="odd">
<td>“hello”, “world”</td>
<td>String</td>
<td>Strings</td>
</tr>
<tr class="even">
<td>[1, 2, 3, 4]</td>
<td>[Integer]</td>
<td>List of Integers</td>
</tr>
<tr class="odd">
<td>(True, 0.5)</td>
<td>(Bool, Double)</td>
<td>Tuple of Bool and Double</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: All type names are upper-case! However, not all upper-case names are types.</p>
<h4 id="operations">Operations</h4>
<p>Haskell has several built-in operations, including:</p>
<ul>
<li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>Comparison: <code>==</code>, <code>/=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li>Logical: <code>&amp;&amp;</code>, <code>||</code></li>
<li>Concatenation: <code>++</code></li>
</ul>
<h3 id="haskell-calling-functions">Haskell: Calling Functions</h3>
<p>Haskell is a functional programming language, and calling functions is straightforward. Here are some examples:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">sqrt</span> <span class="dv">4</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">show</span> <span class="dv">42</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="fu">min</span> <span class="dv">0</span> <span class="dv">42</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="fu">max</span> <span class="dv">0</span> <span class="dv">42</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">-- Incorrect: max 100 42 + 1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">-- Correct: max 100 (42 + 1)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">-- Incorrect: max -42 42</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">-- Correct: max (-42) 0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="fu">not</span> <span class="dt">True</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span>   <span class="co">-- vs   div 4 2 </span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="fu">div</span> <span class="dv">2</span> <span class="dv">4</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="fu">mod</span> <span class="dv">2</span> <span class="dv">4</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="fu">mod</span> <span class="dv">4</span> <span class="dv">2</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="fu">mod</span> <span class="dv">4</span> <span class="dv">3</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="fu">mod</span> (<span class="dv">10</span> <span class="op">+</span> <span class="dv">7</span>) <span class="dv">12</span></span></code></pre></div>
<p><strong>Watch out!</strong> <code>/</code> is floating-point division, while <code>div</code> is integer division.</p>
<p><strong>Watch out!</strong> Enclose subexpressions in parentheses.</p>
<h3 id="haskell-variables-bindings-and-scope">Haskell: Variables, Bindings, and Scope</h3>
<h4 id="some-vocabulary">Some Vocabulary</h4>
<ul>
<li><strong>Binding</strong> (noun) and <strong>bind</strong> (verb): Associate a variable name with an expression. Similar to assignment (noun) and assign (verb).</li>
<li><strong>Value</strong> (noun): The expression to which a name is bound.</li>
<li><strong>Reference</strong> (verb): Use a name in an expression. During evaluation, the name is just an alias for the expression.</li>
<li><strong>Scope</strong>: The region of the program where a name can be referenced. A variable’s scope depends in part on where the variable is bound.</li>
<li><strong>Lookup</strong> (verb) or <strong>resolve</strong> (verb): Evaluate a name; find its value.</li>
</ul>
<p>All variable names are lower-case!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>x <span class="ot">=</span> <span class="dv">21</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>y <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span></code></pre></div>
<p><strong>Top-level bindings</strong> (think “global variables”): The scope of a top-level binding is the entire file (or the rest of the <code>ghci</code> session).</p>
<p><strong>Trick question</strong>: What’s the value of <code>x</code>?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>x <span class="ot">=</span> <span class="dv">24</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>x <span class="ot">=</span> <span class="dv">41</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>If we type this code into a file and try to run it, we will get an error. In <code>ghci</code>, we can type the first and second lines, and get the value of <code>x</code>. We can type the third line, but when we try to get the value of <code>x</code>, <code>ghci</code> goes into an infinite loop!</p>
<p>A scope can bind a name at most once. In other words, all “variables” are constants.</p>
<p><strong>Local bindings</strong> (think “local variables”):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">let</span> x <span class="ot">=</span> <span class="dv">21</span> <span class="kw">in</span> x <span class="op">+</span> x</span></code></pre></div>
<p>The scope of a <code>let</code> variable is the body of the <code>let</code>. The result of the <code>let</code> expression is the result of evaluating the <code>let</code> body.</p>
<p><code>let</code> and <code>in</code> are keywords in Haskell.</p>
<p>A scope can bind a name at most once. In other words, all “variables” are constants.</p>
<p>Scopes can nest:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">let</span> x <span class="ot">=</span> <span class="dv">21</span> <span class="kw">in</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">10000</span> <span class="kw">in</span> x</span></code></pre></div>
<p>Haskell resolves names from inner-most to outer-most scope.</p>
<h3 id="haskell-writing-code-in-files">Haskell: Writing Code in Files</h3>
<p>Plus: comments, loading &amp; reloading code in <code>ghci</code>.</p>
<p>Haskell code files have a <code>.hs</code> extension. To add comments to your code, use the following syntax:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- Single-line comment</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">{- </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co">   Multiline comment</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">-}</span></span></code></pre></div>
<p>Top-level bindings can go in a file, but expressions on their own can’t go in a file. Don’t click the Run button on repl.it. Load the code into <code>ghci</code> instead.</p>
<p>If you have a <code>&lt;file&gt;.hs</code> file, you can load it into <code>ghci</code> with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="op">:</span>load <span class="op">&lt;</span>file<span class="op">&gt;</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="op">:</span>l <span class="op">&lt;</span>file<span class="op">&gt;</span></span></code></pre></div>
<p>If you have already loaded a file, then you modify the file and save it again, you can reload the contents of the file:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="op">:</span>reload</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="op">:</span>r</span></code></pre></div>
<h3 id="haskell-defining-functions">Haskell: Defining Functions</h3>
<p>Plus: local definitions and pattern matching.</p>
<p>Haskell is a functional programming language, and functions are easy to define.</p>
<h4 id="function-calls">Function Calls</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>successor <span class="dv">1</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>average <span class="dv">0</span> <span class="dv">10</span></span></code></pre></div>
<h4 id="function-definitions">Function Definitions</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>successor n <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>average x y <span class="ot">=</span> (x <span class="op">+</span> y) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>The function’s body is an expression. The result of calling the function is the result of evaluating the function’s body, with the argument values bound to the corresponding parameter names.</p>
<h4 id="local-bindings-in-a-function">Local Bindings in a Function</h4>
<p>Three different ways to define x^2 + 1/x^2:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>f x <span class="ot">=</span> x <span class="op">*</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">/</span> (x <span class="op">*</span> x)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>f x <span class="ot">=</span> <span class="kw">let</span> value <span class="ot">=</span> x <span class="op">*</span> x</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>      <span class="kw">in</span> value <span class="op">+</span> <span class="dv">1</span> <span class="op">/</span> value</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>f x <span class="ot">=</span> value <span class="op">+</span> <span class="dv">1</span> <span class="op">/</span> value</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  <span class="kw">where</span> value <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p><code>let</code> expressions are one way to do local variables in a Haskell function. As always, the scope of the <code>let</code> binding is the body of the <code>let</code> expression.</p>
<p><code>where</code> clauses are another way to do local variables in a Haskell function. The scope of the <code>where</code> clause is the body of the function (including the <code>where</code> clause).</p>
<p>Which of these definitions you choose to write is largely a matter of style or convenience.</p>
<h4 id="pattern-matching">Pattern Matching</h4>
<p>Pattern matching is one of Haskell’s superpowers.</p>
<p>A typical definition of <code>fact</code> that uses <code>if</code>/<code>then</code>/<code>else</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>fact n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>         <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>         <span class="kw">else</span> n <span class="op">*</span> fact (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>A definition of <code>fact</code> that uses pattern matching:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>fact <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>fact n <span class="ot">=</span> n <span class="op">*</span> fact (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>When a program calls <code>fact</code>, Haskell tries to match the call’s argument against each pattern, from top to bottom. As soon as it finds a match, Haskell uses that version of the function.</p>
<h3 id="types-in-haskell">Types in Haskell</h3>
<h4 id="some-vocabulary-1">Some Vocabulary</h4>
<ul>
<li><strong>type-safe</strong> (adjective): a program that has no type errors</li>
<li><strong>type-check</strong> (verb): determine whether a program has type errors</li>
<li><strong>static</strong> (adjective): a property of a program that is (or can be) determined without running the program</li>
<li><strong>dynamic</strong> (adjective): a property of a program that is (or can be) determined by running the program</li>
<li><strong>statically typed</strong> (adjective): a programming language with static type checking. Typically, a compiler performs type checking. If the compiler finds a type error, the program does not compile (and therefore can never run).</li>
<li><strong>dynamically typed</strong> (adjective): a programming language with dynamic type checking. An interpreter might perform type-checking as the program runs. If the program has a type error, the program may crash.</li>
<li><strong>type annotation</strong> (noun): information that the programmer provides about the type of a variable, function, etc.</li>
<li><strong>type inference</strong> (noun): a form of type checking that does not require (a lot of) type annotations</li>
</ul>
<p>Haskell is a <strong>statically typed language</strong> that uses <strong>type inference</strong>.</p>
<h4 id="examining-types-in-ghci">Examining Types in <code>ghci</code></h4>
<p>We can ask <code>ghci</code> for the type of an expression using:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="op">:</span><span class="kw">type</span> <span class="op">&lt;</span>expr<span class="op">&gt;</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="op">:</span>t <span class="op">&lt;</span>expr<span class="op">&gt;</span></span></code></pre></div>
<p>Haskell is a statically typed language that uses type inference. We are usually not required to write type annotations, but it’s still a good idea.</p>
<h4 id="function-types-in-haskell">Function Types in Haskell</h4>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>successor n <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>average x y <span class="ot">=</span> (x <span class="op">+</span> y) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<h4 id="function-types-in-haskell-1">Function Types in Haskell</h4>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">successor ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>successor n <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="ot">average ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>average x y <span class="ot">=</span> (x <span class="op">+</span> y) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>“successor is a function that takes an Integer and results in an Integer.”</p>
<p>“average is a function that takes two Doubles and results in a Double.”</p>
<h3 id="functional-programming">Functional Programming</h3>
<h4 id="some-basic-concepts">Some Basic Concepts</h4>
<p><strong>What is functional programming?</strong></p>
<p>In functional programming, computation proceeds by evaluating expressions. This is in contrast to imperative programming, where computation proceeds by updating state. In pure functional programming, evaluating expressions is the only way computation proceeds. Haskell is a pure, functional programming language.</p>
<h3 id="the-essence-of-cs-131">The Essence of CS 131</h3>
<h4 id="abstraction">Abstraction</h4>
<p><strong>“Refactoring”: Eliminating Repeated Code</strong></p>
<p>Consider the following expressions:</p>
<pre><code>2 * 2 + 1
…
3 * 2 + 1
…
… (4 * 2 + 1) ..
…
5 * 2 + 1</code></pre>
<p>We can “factor out” the operation into a helper function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">f ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>f n <span class="ot">=</span> n <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>Now, we can replace the repeated code with calls to the helper function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>f <span class="dv">2</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>…</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>f <span class="dv">3</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>…</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>… (f <span class="dv">4</span>) <span class="op">..</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>…</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>f <span class="dv">5</span></span></code></pre></div>
<p><strong>“Refactoring”: Step-by-step</strong></p>
<ol type="1">
<li><p>Identify the repeated code:</p>
<pre><code>2 * 2 + 1
…
3 * 2 + 1
…
… (4 * 2 + 1) ..
…
5 * 2 + 1</code></pre></li>
<li><p>Write a function with the appropriate type signature:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">f ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>f n <span class="ot">=</span> n <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span></code></pre></div></li>
<li><p>Replace the repeated code with calls to the helper function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>f <span class="dv">2</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>…</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>f <span class="dv">3</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>…</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>… (f <span class="dv">4</span>) <span class="op">..</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>…</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>f <span class="dv">5</span></span></code></pre></div></li>
</ol>
<p>Functions are parameterized expressions. <strong>Abstraction is the essence of CS 131</strong>.</p>
